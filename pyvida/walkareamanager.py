from __future__ import annotations
import copy
import logging
from typing import TYPE_CHECKING
from dataclasses_json import dataclass_json
from dataclasses import (
    dataclass,
    field
)
from typing import (
    Dict,
    List,
    Optional,
    Tuple
)

from .constants import LOGNAME
from .emitter import Emitter
from .utils import (
    crosshair,
    distance,
    float_colour,
    getinsetpoint,
    get_object,
    polygon,
    queue_method,
    DEFAULT_WALKAREA,
    SafeJSON
)


LOCKED = 0
UNLOCKED = 1
FREEROAM = 2

logger = logging.getLogger(LOGNAME)


#@dataclass_json
@dataclass
class WalkAreaManager(SafeJSON):
    """ Walkarea with waypoints """
    scene: Optional[str] = None
    name: str = "walkarea"
    _waypoints: any = field(default_factory=list)  # (x,y,z=[scale for astar]) (z is optional)
    _polygon: any = field(default_factory=list)
    _polygon_waypoints: any = field(default_factory=list)  # autogenerated waypoints from polygon
    _state: any = UNLOCKED

    # for fast calculation of collisions
    _polygon_count: int = 0
    _polygon_x: any = field(default_factory=list)
    _polygon_y: any = field(default_factory=list)
    _fill_colour: any = None

    busy: int = 0

    def __post_init__(self):
        self.editing = False
        self._edit_polygon_index = -1
        self._edit_waypoint_index = -1

    def _set_point(self, x=None, y=None, z=None):  # pragma: no cover
        i = -1
        pts = None
        a = "_polygon"
        if self._edit_polygon_index >= 0:
            i = self._edit_polygon_index
            pts = self._polygon
            a = "_polygon"
        elif self._edit_waypoint_index >= 0:
            i = self._edit_waypoint_index
            pts = self._waypoints
            a = "_waypoints"
        if i >= 0:
            oz = None
            if len(pts[i]) == 2:
                ox, oy = pts[i]
            else:
                ox, oy, oz = pts[i]
            x = x if x else ox
            y = y if y else oy
            z = z if z else oz
            new_pt = (x, y)
            if z:
                new_pt = (x, y, z)
            updated = pts[:i] + [new_pt] + pts[i + 1:]
            setattr(self, a, updated)
            self._update_walkarea()

    def _get_point(self, x=False, y=False, z=False):  # pragma: no cover
        i = -1
        pts = []
        if self._edit_polygon_index >= 0:
            i = self._edit_polygon_index
            pts = self._polygon
        elif self._edit_waypoint_index >= 0:
            i = self._edit_waypoint_index
            pts = self._waypoints
        if i >= 0:
            if len(pts[i]) == 2:
                ox, oy = pts[i]
            else:
                ox, oy, oz = pts[i]
        if x is True:
            return ox
        elif y is True:
            return oy
        else:
            return oz

    def set_pt_x(self, v):
        self._set_point(x=v)

    def set_pt_y(self, v):
        self._set_point(y=v)

    def set_pt_z(self, v):
        self._set_point(z=v)

    def get_pt_x(self):
        return self._get_point(x=True)

    def get_pt_y(self):
        return self._get_point(y=True)

    def get_pt_z(self):
        return self._get_point(z=True)

    def get_scene(self):
        return get_object(self.game, self.scene)

    def edit_nearest_point(self, x, y):  # pragma: no cover
        """
        Used by editor
        """

        self._edit_waypoint_index = -1
        self._edit_polygon_index = -1

        closest_polygon = 0
        closest_distance_polygon = 10000
        for i, pt in enumerate(self._polygon):
            d = distance((x, y), pt)
            if d < closest_distance_polygon:
                closest_polygon = i
                closest_distance_polygon = d

        closest_waypoint = 0
        closest_distance_waypoint = 10000
        for i, pt in enumerate(self._waypoints):
            px, py = pt[0], pt[1]  # ignore possible z value
            d = distance((x, y), (px, py))
            if d < closest_distance_waypoint:
                closest_waypoint = i
                closest_distance_waypoint = d

        if closest_distance_waypoint <= closest_distance_polygon:
            self._edit_waypoint_index = closest_waypoint
        else:
            self._edit_polygon_index = closest_polygon

    def generate_waypoints(self):
        """ Autogenerated waypoints do not have z values and so do not affect astar scaling. """
        # polygon offset courtesy http://pyright.blogspot.com/2011/07/pyeuclid-vector-math-and-polygon-offset.html
        polyinset = []
        OFFSET = -15
        i = 0
        if len(self._polygon) > 0:
            old_points = copy.deepcopy(self._polygon)
            old_points.insert(0, self._polygon[-1])
            old_points.append(self._polygon[0])
            lenpolygon = len(old_points)
            while i < lenpolygon - 2:
                new_pt = getinsetpoint(old_points[i], old_points[i + 1], old_points[i + 2], OFFSET)
                polyinset.append((int(new_pt.x), int(new_pt.y)))
                i += 1
        else:
            polyinset = []
        self._polygon_waypoints = polyinset

    def mirror(self, w):
        """
        Flip walkarea using w(idth) of screen)
        """
        self._polygon = [(w-x[0], x[1]) for x in self._polygon]
        self._waypoints = [(w-x[0], x[1]) for x in self._waypoints]
        self._update_walkarea()

    def _update_walkarea(self):
        self._polygon_count = len(self._polygon)
        self._polygon_x = [float(p[0]) for p in self._polygon]
        self._polygon_y = [float(p[1]) for p in self._polygon]
        self.generate_waypoints()

    @queue_method
    def polygon(self, points):
        """ Set polygon """
        self.immediate_polygon(points)

    def immediate_polygon(self, points):
        """ Set polygon immediately """
        self._polygon = points
        self._update_walkarea()

    def insert_edge_point(self):  # pragma: no cover
        """ Add a new point after the current index
            Used by editor
        """
        if len(self._polygon) == 0:
            self.immediate_reset_to_default()
        if self._edit_polygon_index < 0:
            self._edit_polygon_index = 0
        pt1 = self._polygon[self._edit_polygon_index]
        pt2 = self._polygon[(self._edit_polygon_index + 1) % len(self._polygon)]
        new_pt = pt1[0] + (pt2[0] - pt1[0]) // 2, pt1[1] + (pt2[1] - pt1[1]) // 2
        self._polygon = self._polygon[:self._edit_polygon_index + 1] + [new_pt] \
                        + self._polygon[self._edit_polygon_index + 1:]
        self._update_walkarea()

    def insert_way_point(self):  # pragma: no cover
        """ Add a new way point after the current index.
            Used by editor
        """
        if len(self._polygon) == 0:
            self.immediate_reset_to_default()
        if self._edit_waypoint_index < 0:
            self._edit_waypoint_index = 0

        if len(self._waypoints) <= 1:
            self._waypoints.append((800, 500))  # default position
        else:
            pt1 = self._waypoints[self._edit_waypoint_index]
            pt2 = self._waypoints[(self._edit_waypoint_index + 1) % len(self._waypoints)]
            new_pt = pt1[0] + (pt2[0] - pt1[0]) // 2, pt1[1] + (pt2[1] - pt1[1]) // 2
            self._waypoints = self._waypoints[:self._edit_waypoint_index + 1] \
                              + [new_pt] + self._waypoints[self._edit_waypoint_index + 1:]
        self._update_walkarea()

    @queue_method
    def add_waypoint(self, point):
        self.immediate_add_waypoint(point)

    def immediate_add_waypoint(self, point):
        self._waypoints.append(point)

    @queue_method
    def waypoints(self, points):
        self.immediate_waypoints(points)

    def immediate_waypoints(self, points):
        logging.info("set waypoints now")
        self._waypoints = points

    @queue_method
    def toggle_editor(self):
        self.editing = not self.editing

    @queue_method
    def reset_to_default(self):
        self.immediate_polygon(DEFAULT_WALKAREA)

    @queue_method
    def lock(self):
        """ Lock the walkarea so the player can't walk """
        self.immediate_lock()

    def immediate_lock(self):
        self._state = LOCKED

    @queue_method
    def unlock(self):
        """ Activate the walkarea """
        self.immediate_unlock()

    def immediate_unlock(self):
        self._state = UNLOCKED

    @queue_method
    def freeroam(self):
        """ Make the whole screen a walkarea """
        self.immediate_freeroam()

    def immediate_freeroam(self):
        self._state = FREEROAM

    def collide(self, x, y, ignore=False):
        """ Returns True if the point x,y collides with the polygon """
        if self._state == LOCKED:  # always outside walkarea
            return False
        elif self._state == FREEROAM or ignore is True:  # always inside walkarea
            return True
        c = False
        i = 0
        npol = self._polygon_count
        j = npol - 1
        xp, yp = self._polygon_x, self._polygon_y
        while i < npol:
            if ((((yp[i] <= y) and (y < yp[j])) or
                 ((yp[j] <= y) and (y < yp[i]))) and
                    (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i])):
                c = not c
            j = i
            i += 1
        return c

    def valid(self, x, y, z=None):
        """ Returns True if the point is safe to walk to
         1. Check inside polygon
         2. Check not inside scene's objects' solid area
        """
        inside_polygon = self.collide(x, y)
        outside_solids = True

        if self.scene:
            scene = get_object(self.game, self.scene)
            for obj_name in scene.objects:
                obj = get_object(scene.game, obj_name)
                if not obj:
                    print("ERROR: %s not found in scene even though recorded in scene" % obj_name)
                    continue
                if obj.allow_update and obj.solid_area.collidepoint(x, y) and not isinstance(obj, Emitter):
                    outside_solids = False
                    break
        safe = True if inside_polygon and outside_solids else False
        return safe

    def _pyglet_draw(self, debug=False):
        ypts = [self.game.resolution[1] - y for y in self._polygon_y]
        pts = [item for sublist in zip(self._polygon_x, ypts) for item in sublist]
        #        polygon(self.game, pts)
        if self._fill_colour is not None:
            colours = list(float_colour(self._fill_colour)) * self._polygon_count
            polygon(self.game, pts, colours, fill=True)

        if debug is True:  # pragma: no cover
            colour = (24, 169, 181, 255)
            colours = list(float_colour(colour)) * self._polygon_count
            polygon(self.game, pts, colours)
            for pt in self._polygon:
                crosshair(self.game, pt, colour)

            colour = (255, 96, 181, 255)
            for pt in self._waypoints:
                crosshair(self.game, pt, colour)

            colour = (255, 96, 31, 255)
            scene = self.get_scene()
            if scene:
                for o in scene.objects:
                    o = get_object(self.game, o)
                    if o._allow_draw is True and o != self.game.player and not isinstance(o, Emitter):
                        for pt in o.solid_area.waypoints:
                            if self.collide(*pt):
                                crosshair(self.game, pt, colour)

    def pyglet_draw(self):
        """ walkareamanager.draw """
        self._pyglet_draw()

    def debug_pyglet_draw(self):
        """ walkareamanager debug draw """
        self._pyglet_draw(debug=True)
